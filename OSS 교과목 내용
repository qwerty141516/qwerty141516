16 원격 저장소 복제 Clone   ===========================================================
$ git clone [복사된-주소]
- 원격저장소와 동일한 이름으로 복제

$ git clone [복사된-주소] [새로운-폴더명]
- 하부 폴더 [새로운-폴더명] 이름으로 복제

$ git clone [복사된-주소]
- 현재 폴더에 바로 복제

$ git remote
- 원격 저장소 이름 목록만

$ git remote -v
- 원격 저장소 주소와 이름 목록

$ git remote add origin URL
- 원격 저장소 별칭 저장

$ git remote show origin
- 자세한 정보

$ git remote rename origin org
- 이름 수정

$ git remote rm org
- 삭제

$ git remote show origin(atom)
- 원격 저장소의 모든 브랜치 보기 가능

17 지역과 원격 저장소 연동 push pull   ===========================================================

- 원격 저장소 수정 사항 pull로 지역 저장소로 가져오기
$ git pull origin main
$ git pull

- 원격 저장소 수정 사항 fetch로 지역 저장소로 가져와 병합하기
$ git fetch origin main
$ git fetch
$ git merge origin/main

- 지역 저장소 수정 사항 push로 원격저장소 보내기
$ git push origin main
$ git push




18 지역과 원격 저장소 연동  ===========================================================

원격 저장소 수정 사항 pull로 지역 저장소로 가져오기
$ git pull origin main
$ git pull

원격 저장소 수정 사항 fetch로 지역 저장소로 가져와 병합하기
$ git fetch origin main
$ git fetch
$ git merge origin/main




19 오픈소스 소프트웨어     ===========================================================

OSS: p[en source software
누구나 특별한 제한 없이 그 코드를 보고 사용할 수 있는 오픈소스 라이선스를 만족하는 SW

OSI : open source initiative
공개 소스 정의(OSD)의 관리 및 촉진을 담당하는 비영리 조합
- OSI가 인증하는 공개 소스 소프트웨어(OSS) 인증 마크
  소프트웨어가 실제로 공개소스라는 것을 증명

의미
소프트웨어 소스코드를 자유롭게 읽고, 수정 및 재배포가 가능
- 소프트웨어의 향상과 발전
- 여러 사람들이 고치고 쓰고 버그를 개선하는 것이 보다 빠를 수 있음


자유 소프트웨어(Free Software)
- 리처드 스톨먼, 자유 소프트웨어 재단 설립
GNU 프로젝트와 관련된 소프트웨어에서 자유를 중시

- 카피레프트 (Copyleft, Copyright의 반대되는 개념)
  제작자에게 저작권은 인정하면서 어느 누구나 소프트웨어를 복제해
  사용할 수 있는 권리를 주어야 한다는 개념을 갖는 SW 의미

오픈소스 소프트웨어 장단점
장점:
-소스코드를 공개
-커스터마이징과 혁신 지원

단점:
-공개의 의무, 품질보증 및 유지보수, 보안등의 어려움

대부분의 웹을 지원하는 서비스 스택 모델 : LAMP
L : Linux 
A : Apache 
M : MySQL
P : PHP( Perl, Python )

GPL:
자유소프트웨어재단(FSS)에서 만든 라이선스
- 리처드 스톨만
- 카피레프트
- 목적이나 제한없이 사용 가능
- 2차 수정,배포시 GPL로 공개해야함
| 리눅스 커널, git, 마리아 DB, 워드프레스, 파이어폭스 2.0

AGPL
GPL을 기반으로 만든 라이선스
- 네트워크로 상호작용하는 소프트웨어의 소스코드도 공개해야 한다는 조항을 추가한 라이선스
- 서버에서 프로그램을 실행해서 다른 사용자들과 통신 중
| 몽고 DB 등

LGPL
보다 완화된 GPL 라이선스
- GPL라이센스를 사용할 때 소스코드를 GPL로 공개야하는 부담 때문에 만들어진 라이선스
| 파이어폭스 2.1

Apache License
소스코드 공개에 대한 의무사항은 라이센스에 포함되어 있지 않음
- 아파치 라이센스 소스코드를 수정하고 배포시 라이센스 버전 2.0을 포함시켜야 하고 아파치 재단의 소프트웨어라는 사실을 명시
| 안드로이드, 하둡

MIT License
MIT에서 학생들을 지원하기 위해서 만든 라이선스
- 라이센스와 저작권 관련 명시 의무
- 가장 느슨한 조건을 가지고 있어, 많은 사람이 사요하기 용이
| 부트스트랩, Angular.js, Backbone.js, jQuery

>> $ 오픈소스 소프트웨워의 의미
- 소프트웨어의 소스코드를 자유롭게 읽고, 수정 및 재배포가 가능

>> 오픈소스 소프트웨어 개발을 지원하는 서버인 깃허브에서의 협업 방식
github, gitlab, bitbucket

>> 대표적인 오픈소스 소프트웨어
파이썬, 사이킷런, 파이토치, 텐서플로, MySql, 몽고DB 등

>> 오픈소스 소프트웨어의 저작권을 이해할 수 있다
- 의무강도에 따른 분류
- GPL > LGPL > Apache > BSD > MIT 순으로 의무강도가 낮아짐





20 임시 저장 stash  ===========================================================

= 작업 폴더와 스테이징 영역을 숨김(stash)에 저장하고 작업 폴더를 정리
  $ git stash
  $ git stash -m '메세지'
  $ git stash save
  $ git stash save '메세지'

= 옵션
--keep-index, -k
  · 스테이징 영역을 제외하고 작업 폴더만 저장

--include-untracked, -u
  · Untracked 파일도 포함해 저장


= 최근 임시저장 내용을 가져와 반영, stash 목록은 그대로
기본으로 작업 디렉토리 내용만 다시 복사해 활용
  $ git stash apply

스테이지 영역도 함께 복사하기 위해서는 옵션 사용
  $ git stash apply --index

옵션 -k | --keep-index
  스테이징 영역은 저장하지 않고 그대로 놔둠
  
옵션 -u | --include-untracked
  Untracked 파일도 포함해 저장

옵션 -p | --patch
  변경된 모든 사항들을 저장하는 것이 아니며 대화형 프롬프트를 통해
  자신이 stash에 저장할 것과 저장하지 않을 것을 지정 기능


목록 보기
$ git stash list
  stash@{0}    <--- 가장 최신것이 0번
  stash@{1}
  stash@{2}
  ....


특정 stash 확인

- 해당 stash 항목이 생성되었을 때의 커밋 자료와 최신 stash 항목 간의 차이로 표시
$ git stash show
  h.txt | 2++
  1 file changed, 2 insertions(+) <---------변화된 파일과 변화된 수만 표시

$ git stash show -p
  -p: 파일 내용의 차이까지 보이기

- 해당 stash 항목이 생성되었을 때의 커밋 자료와 해당 stash 항목 간의 차이로 표시
$ git stash show stash@{h}
$ git stash show stash@{n}-p
  -p : 내용의 차이까지 보이기 

- 최근 또는 지정된 임시 저장소 내용을 가져와 반영하고 삭제
$ git stash pop
$ git stash pop stash@{n}

- 최근 또는 지정된 임시저장소 내용을 가져와 반영, 작업 디렉토리만 반영,
stash 목록은 그대로
$ git stash apply
$ git stash apply stash@{n}

- 최근 또는 지정된 임시저장소 내용을 가져와 반영, 작업 디렉토리와 스테이징 영역도 반영, stash 목록은 그대로
$ git stash apply --index
$ git stash apply --index stash@{n}



특정 stash 삭제와 모든 stash 삭제
- 최근 임시저장 내용을 삭제
$ git stash drop

- 지정된 임시저장 내용을 삭제
$ git stash drop stash@{n}

- 모든 stash 목록을 모두 제거
$ git stash clear


Untracked 파일 삭제

- $ git clean
  바로 삭제 되지 않음

- $ git clean -i

- $ git clean -f
  무조건 삭제



21 stash 실습 ===========================================================


22 다양한 브랜치 병합 ===========================================================

병합(merge)
- 두 개의 브랜치를 하나로 모으는 과정
  fast-forward(빨리 감기) 병합
  3-awy 병합

fast-forward 병합 조건
- 현재 브랜치 master가 병합할 대상 커밋의 직접적인 뿌리(조상)가 되는 경우
  간단히 두 브랜치가 일렬 상태
  bugfix 브랜치 이력이 master 브랜치 이력을 모두 포함하는 경우

브랜치 master에서 병합 명령
$ git merge bugfix


3-way 상태 : 두 분기가 갈라진 상태

- 두 브랜치의 조상이 같은 경우
  master  브랜치 내의 변경 내용과 bugfix 브랜치 내의 변경 내용을 하나로 통합할 필요

3-way 병합
  새로운 커밋을 사용하여 두 기록을 합침

병합할 브랜치의 조상이 기준 브랜치인 경우, 즉 일렬 상태에서
- 병합 기본은 fast forward 병합
- 마스터 브랜치에서 브랜치 dev1을 병합
  기본이 fast-forward 병합


기본이 fast forward 상태에서 non fast forward 병합
- 마스터에서 dev1을 fast forward로 병합
  $ git merge dev1

마스터에서 dev1을 non fast forward로 병합 (3-way 병합)
  옵션 --no-ff
    $ git merge dev1 --no-ff


병합의 다양한 옵션 종류

- $ git merge --ff-only {병합할_브랜치_명}
  상태가 fast-Forward인 일령 상태에서만 병합 진행

- $ git merge --squash {병합할_브랜치_명}
  현재 브랜치에 병합 대상과의 합치는 커밋을 하나 생성해 병합
    병합되는 브랜치는 사용하지 않고 그대로 남음


옵션 --squash

- 강압적인(?) 병합
$ git merge --squash hotfix
사전적 의미(짓 뭉개다)에서 알 수 있듯이
  · 커밋 이력과 병합 되는 브랜치 이력도 남기지 않음
  · 새로운 커밋에 상대 브랜치의 내용을 모두 합해 새로운 커밋으로 병합
    → 직접 메세지와 함께 커밋을 해야함

Summary
>> 기준 브랜치에서 hotfix 브랜치 병합
$ git merge hotfix
  · fast-forward, 3-way merge

>> 무조건 3-way 병합 수행
$ git merge --no-ff hotfix

>> fast-forward인 경우에만 병합 진행
$ git merge --ff-only hotfix

>> 현재 브랜치에서 커밋 하나만 생성해서 병합
$ git merge --squash hotfix


23  브랜치 병합 실습 ===========================================================

24 병합 충돌과 해결 ============================================================

충돌 해결
- 직접 파일 내용을 수정 후 저장
- 계속해서 add, commit 진행
- 필요하면 합병된 이전 브랜치 삭제


병합 취소
$ git merge --abort

다시 병합
$ git merge feat/list

Summary
>> 3-way 충돌 발생
$ git merge gotfix

>> 충돌한 파일을 인지하고 파일 수정
$ code file

>> 수정 후 다시 add, commit
$ git commit -am 'msg'

>> 충돌 이후 병합 취소
$ git merge --abort


25 브랜치 리베이스 rebase ====================================================

3-way merge와 rebase 비교

merge
- 여러 분기가 생긴 변경 내용의 이력이 모두 그대로 남아 있기 때문에 이력이 복잡해짐

rebase
- 히스토리가 선형으로 단순해지고 좀 더 깨끗한 이력을 남김
- 원래의 커밋 이력이 변경됨
  정확한 이력을 남겨야 할 필요가 있을 경우에는 사용하면 안됨


fast-forward merge와 rebase 비교

fast-foward merge
- 조상에 위치한 브랜치에서 선행 브랜치의 마지막으로 이동하는 병합

reabse
- 두 갈래의 브랜치에서
  기존의 베이스를 수정
    → 병합할 브랜치 마지막 커밋을 새로운 베이스로 수정하는 병합


3-way 병합 
$ git checkout master
$ git merge experiment




Summary
>> 기준 브랜치에서 main 브랜치 rebase 병합
$ git checkout topic
$ git merge main

>> 다시 main을 돌아와 fast-forward 병합 진행
$ git checkout main
$ git merge topic


